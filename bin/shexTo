#!/usr/bin/env node

// shexToOwl http://tracker.example/schemas/Issue.shex

const fs = require('fs')
let ShExLoader = require('@shexjs/loader')
let ShExToOwl = require('../lib/ShExTo')
const ontologyIRI = "http://ddi-alliance.org/ns/ddi4"

// Generate command line interface
var CLI = require("command-line-args")([
    { name: "help",  alias: "h", type: Boolean },
    { name: "shex",  alias: "x", type: String, multiple:  true, defaultValue: [], defaultOption:  true },
    { name: "json",  alias: "j", type: String, multiple:  true, defaultValue: [] },
    { name: "to",    alias: "t", type: String, defaultValue: 'owl' },
    { name: "prefix",alias: "p", type: String, multiple:  true, defaultValue: [] },
    { name: "append",            type: String, multiple:  true, defaultValue: [] },
    // { name: "prefix",alias: "p", type: String, multiple: true
]);
function abort (msg) {
  console.error(msg);
  if (false)
  console.error(CLI.getUsage({
    title: "shexToOwl",
    description: "load some number of schema files from web or filesystem and display as JSON (ShExJ), for example:\n    shexToOwl http://tracker.example/schemas/Issue.shex",
    footer: "Project home: [underline]{https://github.com/shexSpec/shex.js}"
  }));
  process.exit(1);
}

// Extract user commands
if (CLI.help)
    abort("");
if (CLI.shex.length === 0 && CLI.json.length === 0) abort("no shex specified");
let prefixMap = CLI.prefix.map(
  pair => {
    let m = pair.match(/^([^:]*):\s*(.*)$/)
    if (!m) { throw Error('--prefix argument didn\'t lead with viable prefix: ' + pair) }
    return { prefix: m[1], url: m[2] }
  }
)

let source = {
  resource: CLI.shex.concat(CLI.json).join(', '),
  method: 'shexToOwl',
  timestamp: new Date().toISOString()
}

ShExLoader.load(CLI.shex, CLI.json, [], []).then(function (loaded) {
  let errors = {}
  let formatTransformer = ShExToOwl(loaded.schema, {
    source,
    shorten: CLI.shorten,
    prefixMap: prefixMap,
    suppressDuplicateClasses: true,
    append: CLI.append.map(
      filepath => fs.readFileSync(filepath, 'UTF-8')
    ).join(''),
    errors: errors
  })
      
  // { v: owlx, s: OWLXMLSerializer(schema, chattyOWL), m: OWLXMLMarkup() },
  // { v: shexc, s: ShExCSerializer(schema, nestInlinableStructure), m: ShExCMarkup() },
  // { v: shexh, s: ShExCSerializer(schema, nestInlinableStructure), m: ShExHMarkup(schema) }
  let format, markup
  if (CLI.to === 'owl') {
    format = formatTransformer.format.owl(true)
    markup = formatTransformer.markup.xml(ontologyIRI, prefixMap, source)
  } else if (CLI.to === 'shexc') {
    format = formatTransformer.format.shex(true)
    markup = formatTransformer.markup.compact(ontologyIRI, prefixMap, source)
  } else if (CLI.to === 'shexh') {
    format = formatTransformer.format.shex(true)
    markup = formatTransformer.markup.html(ontologyIRI, prefixMap, source)
  } else {
    throw Error('unknown format: --to ' + CLI.to)
  }
  console.log('%s', formatTransformer.run(format, markup, true, true));
  if (CLI.to === 'owl' && 'untyped' in errors) {
    Object.keys(errors.untyped).forEach(badP => {
      let rec = errors.untyped[badP]
      console.warn(`${rec.shapeLabel} ${rec.predicate} :\n  ${rec.newType} isn\'t related to ${rec.curType}\n  ${rec.references.length} later references:`)
      rec.references.forEach(ref => {
        console.warn(`  ${ref.shapeLabel} : ${ref.newType}`)
      })
    })
  }
}).catch(function (e) {
  console.error("aborting:", e.stack || e);
  process.exit(1);
})
