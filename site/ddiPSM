#!/usr/bin/env node

// Generate command line interface
var CLI = require("command-line-args")([
    { name: "help", alias: "h", type: Boolean },
    { name: "out",  alias: "o", type: String, description: "file prefix for json, owl, and shex" },
    { name: "xmi",  alias: "i", type: String, description: "input XMI file" },
    { name: "nestShapes",       type: Boolean, description: "nest inner shapes with no coreferences", defaultOption:  false }
]);
function abort (msg) {
  console.error(msg);
  console.error(CLI.getUsage({
    title: "ddiPSM",
    description: "DDI-specific tweaks for UML Model",
    footer: "Project home: [underline]{https://github.com/shexSpec/shex.js}"
  }));
  process.exit(1);
}

// Extract user commands
if (CLI.help)
    abort("");
if (!CLI.xmi) abort("no input XMI specified (--xmi)");
if (!CLI.out) abort("no output file prefix specified (--out)");



const XSD = 'http://www.w3.org/2001/XMLSchema#'
const UMLP = 'http://www.omg.org/spec/UML/20110701/PrimitiveTypes.xmi#'
const RDFS = 'http://www.w3.org/2000/01/rdf-schema#'
const SHEXMI = 'http://www.w3.org/ns/shex-xmi#'
const DDI = 'http://ddi-alliance.org/ns/#'
const normalizeType = function (type) {
  if (!type) {
    return type // pass undefined on
  }
  if (type === 'xs:language') {
    return XSD + 'language'
  }
  let dtList = [
    { from: UMLP + 'String', to: XSD + 'string' },
    { from: UMLP + 'Integer', to: XSD + 'integer' },
    { from: UMLP + 'Boolean', to: XSD + 'boolean' },
    { from: UMLP + 'Real', to: XSD + 'double' },
    { from: UMLP + 'UnlimitedNatural', to: XSD + 'double' }
  ]
  let dtMap = dtList.reduce(
    (acc, elt) => objSet(acc, elt.from, elt.to),
    {}
  )
  if (type in dtMap) {
    return dtMap[type]
  }
  if (type.startsWith(UMLP)) {
    throw Error('unknown datatype ' + type)
    // return UMLD + type.substr(UMLP.length)
  }
  return type
}

const fs = require('fs')
const UmlModel = require('../doc/uml-model')()
const CanonXmiParser = require('../doc/canonical-uml-xmi-parser')
const ShEx = require('shex')
const UmlParser = CanonXmiParser({
  umlModel: UmlModel,
  viewPattern: /Functional999Views/,
  normalizeType: normalizeType,
  nameMap: {
    // 'Views (Exported from Drupal)': 'Views',
    // 'Class Model (Exported from Drupal)': 'ddi4_model',
    'ClassLibrary': 'ddi4_model', // minimize diffs
    'FunctionalViews': 'Views',
  }
})

let source = {
  method: 'xmi-to-json',
  resource: CLI.xmi,
  timestamp: new Date().toISOString()
}
UmlParser.parseXMI(fs.readFileSync(CLI.xmi, 'UTF-8'), source, (err, xmiGraph) => {
  if (err) {
    throw err
  }
  let model = UmlParser.toUML(xmiGraph)

  // Remove realizes properties.
  model.list('Class').forEach(
    cls => cls.properties.filter(
      prp => prp.name === 'realizes'
    ).forEach(
      prp => prp.remove(model.missingElements)
    )
  )
  // Remove everying inside *Pattern packages.
  model.list('Package').filter(
    pkg => pkg.name.endsWith('Pattern')
  ).forEach(
    pkg => pkg.remove(model.missingElements)
  )

  // Switch to XSD datatypes.
  let xsdTypeFixups = {
    'DDI4_PIM-ClassLibrary-XMLSchemaDatatypes-anyURI': XSD + 'anyURI',
    'DDI4_PIM-ClassLibrary-XMLSchemaDatatypes-language': XSD + 'language'
  }
  model.list('Datatype').filter(d => Object.keys(xsdTypeFixups).indexOf(d.id) !== -1).forEach(d => {
    d.name = xsdTypeFixups[d.id]
    d.external = true

    // Remove d from its containing Package so d doesn't show up in the ShEx.
    let p = d.references.find(r => r.rtti === 'Package')
    let idx = p.elements.indexOf(d)
    p.elements.splice(idx, 1)
  })

  // Remove properties with missing types.
  let removeProps = model.list('Class').reduce((acc, c) =>
    acc.concat(c.properties.filter(p => p.type.rtti === 'MissingElement')
               .map(p => { return { class: c, property: p } })), [])
  if (removeProps) {
    console.warn('Warning: removing ' + removeProps.length + ' badly-typed properties:')
    removeProps.forEach(missing => {
      console.warn('  ' + missing.class.name + ' ' + missing.property.name + ' missing ' + missing.property.type.id)
      missing.property.remove(model.missingElements)
    })
  }

  fs.writeFileSync(CLI.out + '.json', UmlModel.toJSON(model), { encoding: 'utf-8' })

  let shexj = model.toShExJ({
    anyURIasDataProperty: false,
    iri: function (suffix, elt) {
      return DDI + suffix
    },
    annotations: function (elt) {
      // ShEx 2.0 doesn't allow annotations on NodeConstraints.
      if (elt.type === 'Enumeration' || elt.type === 'Datatype') { return [] }
      let ret = [{
        "type": "Annotation",
        "predicate": RDFS + "definedBy",
        "object": "http://lion.ddialliance.org/ddiobjects/" + elt.name.toLowerCase()
      }]

      let pkg = (elt.references || []).find(ref => ref instanceof UmlModel.Package)
      if (pkg) {
        ret = ret.concat({
          "type": "Annotation",
          "predicate": "http://www.w3.org/ns/shex-xmi#package",
          "object": {
            "value": DDI + pkg.name // just the inner-most package
          }
        })
      }
      if (elt.comments) {
        ret = ret.concat(elt.comments.map(comment => { return {
          "type": "Annotation",
          "predicate": "http://www.w3.org/ns/shex-xmi#comment",
          "object": {
            "value": trimUnusedMarkdownHeaders(comment),
            "type": "https://github.com/commonmark/commonmark.js"
          }
        }}))
      }
      if (elt.aggregation) {
        ret = ret.concat({
          "type": "Annotation",
          "predicate": "http://www.w3.org/ns/shex-xmi#partonomy",
          "object": {
            "value": (elt.aggregation === UmlModel.Aggregation.shared
                      ? "shexmi:sharedAggregation"
                      : elt.aggregation === UmlModel.Aggregation.composite
                      ? "shexmi:compositeAggregation"
                      : "\"???\"")
          }
        })
      }
      return ret
    }
  })

  /** get rid of markdown headers with no following section
   *
   *   "Ab\n==\nAb 1\nAb 2\n\nCd\n==\n\nEf\n==\n\nGh\n==\nGh 1\nGh 2\nIj\n=="
   *  =>
   *   "Ab\n==\nAb 1\nAb 2\n\nGh\n==\nGh 1\nGh 2\n"
   */
  function trimUnusedMarkdownHeaders (text) {
    let oldLen
    do {
      oldLen = text.length
      text = text.replace(/[^=\n]+\n=+(?:\n\n+([^=]+\n=+\n)|\s*$)/, '$1')
    } while (text.length < oldLen)
    return text
  }

  fs.writeFileSync(CLI.out + '.shexj', JSON.stringify(shexj, null, 2), { encoding: 'utf-8' })

  // Render package and view hierarchy.
  let owlx = []
  function visitPackage (pkg, parent) {
    pkg.elements.forEach(elt => {
      if (elt.rtti === 'Import') {
        elt = elt.target
      } else if (elt.rtti !== 'Package') {
        return // package members are covered by shexToOwl
      }
      let eltName = 'ddi:' + elt.name
      if (elt.rtti === 'Package' && !eltName.match(/Views?$/) && parent) {
        eltName = eltName + '_Package'
      }
      if (parent) {
        owlx.push(`    <SubClassOf>
        <Class abbreviatedIRI="${eltName}"/>
        <Class abbreviatedIRI="${parent}"/>
    </SubClassOf>`)
      }
      if ('comments' in elt) {
        elt.comments.forEach(comment => {
          owlx.push(`    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <AbbreviatedIRI>${eltName}</AbbreviatedIRI>
        <Literal datatypeIRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral">${encodeCharData(trimMarkdown(comment))}</Literal>
    </AnnotationAssertion>`)
        })
      }
      if (elt.rtti === 'Package') {
        visitPackage(elt, eltName)
      }
    })
  }
  model.elements.forEach(pkg => {
    visitPackage(model, null)
  })
  fs.writeFileSync(CLI.out + '-packagesAndViews-OWL.xml', owlx.join('\n'), { encoding: 'utf-8' })

  if (CLI.nestShapes) {
    let compiled = ShEx.Util.ShExJtoAS(shexj)
    let renamed = ShEx.Util.nestShapes(shexj, {
      transform: function (id, shapeExpr) {
        if (!id.startsWith(DDI)) {
          throw Error('transformation target "' + id + '" doesn\'t start  with "' + DDI + '"')
        }
        return '_:' + id.substr(DDI.length)
      }
    }) // .map(l => l.substr(DDI.length))
    let listFile = CLI.out + '-nested.list'
    let nested = ShEx.Util.AStoShExJ(compiled)
    console.log('simplied ' + Object.keys(renamed).length + ' shapes. see ' + listFile)
    fs.writeFileSync(listFile, JSON.stringify(renamed, null, 2), { encoding: 'utf-8' })
    fs.writeFileSync(CLI.out + '-nested.shexj', JSON.stringify(nested, null, 2), { encoding: 'utf-8' })
  }

})

function objSet (obj, key, value) {
  let add = { }
  add[key] = value
  return Object.assign({}, obj, add)
}

function trimMarkdown (md) {
  return md.replace(/\u001e/g, '\n').replace(/^[^ \t].*\n=+\n\n/mg, '').trim()
}

function encodeCharData (text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}

